// 주난의 난(難)
// 시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
// 2 초	512 MB	1053	583	427	57.938%
// 문제
// 주난이는 크게 화가 났다. 책상 서랍 안에 몰래 먹으려고 숨겨둔 초코바가 사라졌기 때문이다. 주난이는 미쳐 날뛰기 시작했다. 사실, 진짜로 뛰기 시작했다.

// ‘쿵... 쿵...’

// 주난이는 점프의 파동으로 주변의 모든 친구들을 쓰러뜨리고(?) 누군가 훔쳐간 초코바를 찾으려고 한다. 주난이는 N×M크기의 학교 교실 어딘가에서 뛰기 시작했다. 주난이의 파동은 상하좌우 4방향으로 친구들을 쓰러뜨릴(?) 때 까지 계속해서 퍼져나간다. 다르게 표현해서, 한 번의 점프는 한 겹의 친구들을 쓰러뜨린다. 다음의 예를 보자.

// 1 # 1 0 1 1 1
// 1 1 0 1 0 0 1
// 0 0 1 * 1 1 1
// 1 1 0 1 1 1 1
// 0 0 1 1 0 0 1
// 주난이를 뜻하는 *은 (3, 4)에 있고, 초코바를 가진 학생 #는 (1, 2)에 있다. 0은 장애물이 없는 빈 공간임을 뜻하고, 1은 친구들이 서있음을 의미한다. 다음은 주난이의 점프에 따른 생존(?) 학생들의 변화이다.

// 1 # 1 0 1 1 1
// 1 1 0 0 0 0 1
// 0 0 0 * 0 1 1
// 1 1 0 0 1 1 1
// 0 0 1 1 0 0 1
 

// 1 # 0 0 0 0 1
// 0 0 0 0 0 0 0
// 0 0 0 * 0 0 1
// 0 0 0 0 0 1 1
// 0 0 0 0 0 0 1
 

// 0 X 0 0 0 0 0
// 0 0 0 0 0 0 0
// 0 0 0 * 0 0 0
// 0 0 0 0 0 0 1
// 0 0 0 0 0 0 0
// 위의 예시에서 주난이는 3번의 점프 만에 초코바를 훔쳐간 범인을 찾아낼 수 있다!

// 주난이를 빨리 멈춰야 교실의 안녕을 도모할 수 있다. 주난이에게 최소 점프 횟수를 알려줘서 교실을 지키자.

// 입력
// 첫째 줄에 주난이가 위치한 교실의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 300)

// 둘째 줄에 주난이의 위치 x1, y1과 범인의 위치 x2, y2가 주어진다. (1 ≤ x1, x2 ≤ N, 1 ≤ y1, y2 ≤ M)

// 이후 N×M 크기의 교실 정보가 주어진다. 0은 빈 공간, 1은 친구, *는 주난, #는 범인을 뜻한다.

// 출력
// 주난이가 범인을 잡기 위해 최소 몇 번의 점프를 해야 하는지 출력한다.

// 예제 입력 1 
// 5 7
// 3 4 1 2
// 1#10111
// 1101001
// 001*111
// 1101111
// 0011001
// 예제 출력 1 
// 3
// 예제 입력 2 
// 3 5
// 3 5 1 1
// #0000
// 11111
// 0000*
// 예제 출력 2 
// 2
// 예제 입력 3 
// 3 3
// 2 2 1 1
// #00
// 0*0
// 000
// 예제 출력 3 
// 1
// 힌트
// 파동은 호수에 떨어진 돌맹이의 물 파동처럼 상하좌우 네 방향으로 장애물(친구들)을 만날 때 까지 계속해서 퍼져나간다.

// # 0 0 0 0
// 1 1 1 1 1
// 0 0 0 0 *
// 에서 첫 점프 후에는

// # 0 0 0 0
// 0 0 0 0 0
// 0 0 0 0 *
// 가 되며, 이후 한 번의 추가 점프를 통해 파동이 #에 도달하여 범인을 잡을 수 있다.

#include <stdio.h>
#include<algorithm>
#include<queue>
using namespace std; 
char a[301][301];
int n, m, x1, y1, x2, y2; 
typedef pair<int, int> pii;
int visited[301][301];
const int dy[4] = {-1, 0, 1, 0};
const int dx[4] = {0, 1, 0, -1};
int ret; 
queue<int> q;
int main(){
    scanf("%d %d", &n, &m);
    scanf("%d %d %d %d", &y1, &x1, &y2, &x2);
    y1--, x1--, y2--, x2--; 
    for(int i = 0; i < n; i++){
        scanf("%s", a[i]); 
    }  
    q.push(1000 * y1 + x1);
    visited[y1][x1] = 1; 
    int cnt = 0; 
    while(a[y2][x2] != '0'){ 
        cnt++;
        queue<int> temp; 
        while(q.size()){
            int y = q.front() / 1000; 
            int x = q.front() % 1000;  
            q.pop();  
            for(int i = 0; i < 4; i++){
                int ny = y + dy[i]; 
                int nx = x + dx[i];
                if(ny < 0 || ny >= n || nx < 0 || nx >= m || visited[ny][nx]) continue; 
                visited[ny][nx] = cnt;  
                if(a[ny][nx] != '0'){
                    a[ny][nx] = '0'; 
                    temp.push(1000 * ny + nx);
                }
                else q.push(1000 * ny + nx); 
          }
        }
        q = temp;  
    }
    printf("%d\n", visited[y2][x2]); 
}



